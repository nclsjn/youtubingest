# Youtubingest

Youtubingest is a FastAPI application that extracts and processes YouTube content (videos, playlists, channels, search queries) into text optimized for Large Language Models (LLMs).

## Features

* Ingest content from YouTube videos, playlists, channels (by ID, handle, custom URL, username), or search terms.
* Extract key video metadata (title, description, duration, publish date, channel info, tags).
* Retrieve and format video transcripts with configurable time-based grouping.
* Clean text content (titles, descriptions) for better LLM usability.
* Filter videos by publication date.
* Calculate estimated token count for the generated digest (using TikToken).
* Provides a simple web interface for interaction and testing.
* Offers a REST API for programmatic use.
* Includes rate limiting, metrics, and basic security middleware.
* Optional API key encryption support.
* Centralized cache management for improved performance and memory usage.
* Robust error handling with standardized error responses.

## Requirements

* Python 3.8 or higher
* A YouTube Data API v3 key

## Installation

1.  **Clone the repository:**
    ```bash
    git clone https://github.com/nclsjn/youtubingest.git
    cd youtubingest
    ```

2.  **Create and activate a virtual environment (recommended):**
    ```bash
    # On Linux/macOS
    python3 -m venv venv
    source venv/bin/activate

    # On Windows
    python -m venv venv
    .\venv\Scripts\activate
    ```

3.  **Install dependencies:**
    ```bash
    pip install -r requirements.txt
    ```
    *Note: For reproducible builds, it's highly recommended to use the pinned versions generated by `pip freeze > requirements.txt` after ensuring your environment works.*

4.  **Configure Environment Variables:**
    * Copy the example environment file:
        ```bash
        cp .env.example .env
        ```
    * Edit the `.env` file and add your YouTube API key:
        ```dotenv
        YOUTUBE_API_KEY="YOUR_ACTUAL_YOUTUBE_API_KEY"
        ```
    * Review other settings in `.env` (like `ALLOWED_ORIGINS` if deploying) and adjust if needed. See the [Configuration](#configuration) section below and the comments in `.env.example` for details.

## Configuration

The application is configured via environment variables, typically loaded from a `.env` file. See `.env.example` for a full list of configurable options.

Key variables:

* `YOUTUBE_API_KEY` (Required): Your YouTube Data API v3 key.
* `ALLOWED_ORIGINS`: Comma-separated list of origins allowed to access the API (CORS). Important for deployment. Example: `"http://localhost:8000,https://your-frontend-domain.com"`
* `HOST`: Server host (default: `127.0.0.1`).
* `PORT`: Server port (default: `8000`).
* `DEBUG`: Set to `true` for development mode (enables auto-reload) (default: `false`).
* `LOG_LEVEL_CONSOLE`/`LOG_LEVEL_FILE`: Set logging levels (default: `INFO`/`DEBUG`).
* `LOG_STRUCTURED`: Use structured JSON logging (`true`/`false`) (default: `true`).

Optional variables for API key encryption (require `cryptography` package):

* `YOUTUBE_API_KEY_PASSWORD`: Password to derive the encryption key.
* `YOUTUBE_API_KEY_SALT`: A unique, fixed salt (base64 encoded recommended) used with the password.

Refer to `config.py` and `.env.example` for more advanced options (rate limits, cache settings, timeouts, etc.).

## Usage

1.  **Start the server:**
    ```bash
    python server.py
    ```
    By default, the server will run on `http://127.0.0.1:8000` and attempt to open your web browser automatically (disable with `AUTO_OPEN_BROWSER=false` in `.env`).

2.  **Access the Web Interface:**
    Open your browser to `http://127.0.0.1:8000` (or the configured host/port). The interface allows you to easily send requests to the `/ingest` endpoint.

3.  **Use the API Programmatically:**
    See the [API Documentation](#api-documentation) section below.

## Architecture

Youtubingest is built with a modular architecture that emphasizes maintainability and performance. While designed with AI assistance, the architecture follows several good practices:

### Cache Management

The application uses a centralized cache management system (`cache_manager.py`) that:

* Provides a unified interface for registering and clearing different types of caches
* Supports both function caches (decorated with `@lru_cache`) and custom LRU caches
* Automatically clears caches when memory pressure is detected
* Provides statistics on cache usage and performance
* Optimizes memory usage by clearing caches when needed

### Error Handling

The error handling system (`exceptions.py`) provides:

* A hierarchy of application-specific exceptions that extend from `AppBaseError`
* Consistent error codes, HTTP status codes, and retry-after headers
* A centralized `handle_exception` function that converts any exception to an appropriate `HTTPException`
* Standardized error responses across all API endpoints

### Performance Optimization

The application includes several performance optimizations:

* Batch processing of transcripts to avoid creating too many tasks at once
* Pre-allocation of memory for better performance
* Compilation of regular expressions once for better performance
* Caching of frequently used functions and data
* Asynchronous processing of concurrent requests
* Memory monitoring to detect and handle memory pressure

### Testing

The application includes a comprehensive test suite:

* Unit tests for core components (engine, cache, memory monitor)
* Integration tests for API endpoints
* Performance tests for critical paths
* Memory usage tests to ensure efficient resource utilization

## API Documentation

The API provides several endpoints under the `/` prefix (as defined in `api/routes.py`):

### `POST /ingest`

Processes a YouTube URL or search term and returns a digest.

* **Request Body:** (`application/json`)
    * `url` (string, required): YouTube video/playlist/channel URL, handle (@username), or search term.
    * `include_transcript` (boolean, optional, default: `true`): Whether to include transcripts.
    * `include_description` (boolean, optional, default: `true`): Whether to include video descriptions.
    * `transcript_interval` (integer, optional, default: `10`): Grouping interval in seconds for transcripts (0 = no timestamps/grouping, allowed: 0, 10, 20, 30, 60). Uses default from `config.py` if null or invalid.
    * `start_date` (string, optional, default: `null`): ISO 8601 date (e.g., `YYYY-MM-DD`). Filter videos published on or after this date (UTC).
    * `end_date` (string, optional, default: `null`): ISO 8601 date (e.g., `YYYY-MM-DD`). Filter videos published on or before this date (UTC).

* **Success Response:** (`200 OK`, `application/json`) - Structure based on `IngestResponse` model (`models.py`):
    ```json
    {
      "source_name": "string",
      "digest": "string",
      "video_count": 0,
      "processing_time_ms": 0.0,
      "api_call_count": 0,
      "token_count": 0,
      "api_quota_used": 0,
      "high_quota_cost": false,
      "videos": [ /* List of Video objects (see models.py) */ ]
    }
    ```

* **Error Responses:**
    * `400 Bad Request`: Invalid input (e.g., missing URL, invalid date format).
    * `403 Forbidden`: API Key issue or Quota Exceeded.
    * `404 Not Found`: YouTube resource not found.
    * `413 Request Entity Too Large`: Request body size exceeds limit.
    * `429 Too Many Requests`: Rate limit exceeded.
    * `500 Internal Server Error`: Unexpected server error.
    * `503 Service Unavailable`: API configuration error, circuit breaker open, or initialization failure.
    (Error responses follow the `ErrorResponse` model from `models.py`)

### `GET /health`

Checks the operational status of the service and its components.

* **Success Response:** (`200 OK`, `application/json`)
    * Returns a JSON object with status, timestamp, version, component readiness, and detailed statistics (API usage, caches, memory, etc.).

### `POST /clear-caches`

Manually clears all internal application caches (API responses, transcripts, etc.). Use with caution.

* **Success Response:** (`200 OK`, `application/json`)
    * Returns a JSON object confirming success and details about cleared caches.
* **Error Response:** (`500 Internal Server Error`) if clearing fails.

### `POST /check-input-type`

Checks if the provided input (`url` field in JSON body) is likely a search query (high API cost) or another type (video, playlist, channel URL).

* **Request Body:** (`application/json`)
    ```json
    { "url": "string" }
    ```
* **Success Response:** (`200 OK`, `application/json`)
    ```json
    {
      "is_search": boolean,
      "input_type": "string", // e.g., "video", "playlist", "channel", "search", "invalid", "empty", "error"
      "high_cost_warning": boolean,
      "message": "string"
    }
    ```
* **Error Response:** (`503 Service Unavailable`) if the API client isn't ready.

## Documentation

For detailed documentation, please refer to the following resources:

- [API Documentation](docs/api.md) - Description of endpoints, parameters, and responses
- [Project Architecture](docs/architecture.md) - Overview of the architecture and components
- [Development Guide](docs/development.md) - Instructions for developers

## Contributing

Contributions are welcome! Please read the [CONTRIBUTING.md](CONTRIBUTING.md) file for guidelines on how to contribute to this project.

*Note: French versions of this README and the CONTRIBUTING guide are available as [README_FR.md](README_FR.md) and [CONTRIBUTING_FR.md](CONTRIBUTING_FR.md).*

## About the Author and Project

I am not a professional developer. This application was entirely developed with the assistance of AI tools. While I've made every effort to ensure the application works correctly, it may not follow all best practices and could contain imperfections.

The project serves as an example of what can be achieved with AI assistance in software development, even without formal programming experience. I welcome contributions from experienced developers to improve the codebase.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
